## keyword

### パターンとは
- パターンは繰り返すものである
- パターンは経験から見つかるものである
- パターンは問題への解答である
- パターンには適材適所がある
- パターンには大小の粒度がある
- パターンは理解の単位である
- パターンは人や自分に伝えるものである

### ソフトウェアのパターン
- アーキテクチャパターン
    - 抽象度の高い『構造』を指す
    - システム全体を決定する
    - i.e.) MVCアーキテクチャ
- アナリシスパターン
    - ビジネスロジックの『分析』で用いる
    - コンピュータのシステムには依存しない
    - i.e.) パーティパターン（類似部分をひとまとめと考える）
- デザインパターン
    - 『設計』で用いる
- イディオム
    - 『製造』で用いる
    - 別名：プログラミングパターン
    - 特定の言語に特化している
    
#### 使用関係    
アーキテクチャパターン -> アナリシスパターン -> デザインパターン -> イディオム

### デザインパターンのメリット
- 共通の語彙を持てる
- メリットとデメリットが洗い出されている
- 設計の考察に便利
- 設計の目標が立てられる
- 問題解決策をくれる
- 適用範囲が広い
- 効率的に良い設計を学べる

### デザインパターンの落とし穴
- デザインパターンは思考のサポートツールでしかない
- なんでもかんでもデザインパターンを適用しない
- デザインパターンも変形する
- デザインパターンは組み合わせて使ってもよい


### GoF 23パターン


|　|生成|構造|振舞|
|---|---|---|---|
|クラス|ファクトリメソッド|アダプター(クラス)|インタープリタ|
|　|　|　|テンプレートメソッド|
|オブジェクト|アブストラクトファクトリ|アダプター(オブジェクト)|チェーンオブレスポンシビリティ|
|　|ビルダー|ブリッジ|コマンド|
| |プロトタイプ|コンポジット|イテレータ|
| |シングルトン|デコレータ|メディエータ|
| | |ファサード|メメント|
| | |フライウェイト|オブザーバ|
| | |プロキシ|ステート|
| | | |ストラテジー|
| | | |ビジター|


### 概要

#### 生成
1. Abstract Factory:
    - 関連するオブジェクトの生成方法をグループ化する
    - 具体的なオブジェクトを特定せずに生成するインターフェース
1. Builder: 
    - オブジェクトの生成処理を担当する
1. Factory Method:
    - インターフェースを介することで、直接的に具象クラスを明示してオブジェクト生成を行わなくする
1. Prototype:
    - サンプルオブジェクトをコピーしてクライアントに提供する
1. Singleton: 
    - システム内に同オブジェクトが1つしかないことを保証する
    
#### 構造
1. Adapter:
    - インターフェースによる変換で、互換性のないクラスを利用する
1. Bridge:
    - 抽象インターフェースを2つに分解して、自由に変更できるようにする 
1. Composite:
    - 集団と要素それぞれのオブジェクトを同様に扱う
1. Decorator:
    - オブジェクトへ動的に機能を追加する
1. Facade:
    - サブシステム用のインターフェースを使って利用を簡単にする
1. Flyweight:
    - 細粒度のオブジェクトを共有し、オブジェクト格納コストを減らす
    - 共有オブジェクトは使用状況に依存しない
1. Proxy:
    - サーバへアクセスするときに使う

#### 振舞
1. Chain of Responsibility:
    - クライアントの要求を処理するオブジェクトを繋ぐ
    - 繋いだオブジェクトの中から任意のオブジェクトが処理を担当する
1. Command:
    - クライアントの要求をカプセル化する
    - 動作タイミングはわかるが具体的な処理がわからないときに有効
1. Interpreter:
    - 言語の文法をオブジェクトで表す
    - オブジェクトを利用して文を解釈する
1. Iterator:
    - 集約したオブジェクトの中身にアクセスする統一化された手段
1. Mediator:
    - オブジェクト間の協調を集中管理する
    - オブジェクト同士を疎結合にすることが目的
1. Memento:
    - カプセル化を侵害しなあいように内部状態を保存し、あとでその状態に戻せる
1. Observer:
    - あるオブジェクトが状態を変えたとき、依存するオブジェクトに状態変更を通知する
1. State:
    - 状態によって異なる振舞いをする状態オブジェクトを作る
    - クラス内に状態変化に関する記述が不要となり、処理を任せることができる
1. Strategy:
    - アルゴリズムの実装をカプセル化し、クライアント側へ影響を与えず変更や交換ができる
1. Template Method:
    - スーパークラスのメソッドで手順を決めておく
    - 実装はサブクラスに任せる
1. Visitor:
    - クラスの要素は変更せず、新しい操作を定義できる
